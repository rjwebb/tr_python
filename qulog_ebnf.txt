(* The EBNF grammar for qulog *)

(* 

We assume the following non-terminals that group tokens. All other
tokens in the grammar are given as strings.

atom:  the allowed atoms of qulog
string:  double-quoted strings
var: the variables of qulog
int: integers
num: floating point numbers

*)

any_number = int | num;

(* ------ program item ------ *)
(* Note: a program file is parsed one program item at a time *)

program_item = 
    type_definition |
    declaration |
    function_rule_definition |
    relation_rule_definition |
    action_rule_definition |
    tr_program_definition;

(* ------ type definitions ------ *)

type_definition = definition_head, "::=", definition_type;

(* either atom type or polymorphic type with one arg *)
definition_head =  atom | ( atom, var ) | ( atom, "(", var, ")" ); 
       
definition_type =
      ( int, "..", int ) | 
      ( atom, "|", atom, {"|", atom} ) |
      ( string, "|", string, {"|", string} ) |
      ( any_number, "|", any_number, {"|", any_number} ) |
      ( compound, "|", compound, {"|", compound} ) |
      ( atom_or_compound,  "||",  
              atom_or_compound,  {"||", atom_or_compound} ) |
      ( "(", definition_type, ")" ) |
      atom |               (* type macro *)
      compound |           (* type macro *)
      type_expression;

atom_or_compound = atom | compound;
atom_or_simple_compound = atom | simple_compound;

(* ------ types ------ *)

simple_type_expression =
     ( "(", ")" ) | 
     var |
     atom |
     compound |
     ( "[", type_expression, "]" ) |
     ( "{", type_expression, "}" ) |
     ( "(", type_expression, ")" ) |
     ( "(", type_expression, ",", type_expression, 
             {",", type_expression}, ")" ) (* tuple type_expression *);

type_expression =
     simple_type_expression |
     function_type_expression |
     relation_type_expression |
     action_type_expression |
     tr_type_expression;

type_expression_seq = type_expression, {",", type_expression};

fun_rel_act_tr_type_expression_seq =
    fun_rel_act_tr_type_expression |
    fun_rel_act_tr_type_expression, {"|", fun_rel_act_tr_type_expression};

fun_rel_act_tr_type_expression =
    annotated_type_expression;

declaration_type_expression = 
    ( "(", annotated_type_expression, 
           {",", annotated_type_expression}, ")" ) |
    annotated_type_expression;

function_type_expression_seq = 
    function_type_expression, ["|", !, function_type_expression_seq];
function_type_expression = 
    ( "(", function_type_expression, ")" ) | 
    ( domain_type_expression, "->",  type_expression ) |
    ( domain_type_expression, "->",  function_type_expression );

domain_type_expression =
    (basic_inner_annotated_type_expression | annotated_tuple_type_expression) |
     relation_type_expression |
     action_type_expression |
     tr_type_expression;
    

relation_type_expression_seq = 
    relation_type_expression, ["|", !, relation_type_expression_seq];
relation_type_expression = 
    (basic_inner_annotated_type_expression | annotated_tuple_type_expression), 
         "<=", !;


action_type_expression_seq = 
    action_type_expression, {"|", action_type_expression};
action_type_expression = 
    (basic_inner_annotated_type_expression | annotated_tuple_type_expression), 
          "~>>", !;

tr_type_expression = 
    simple_type_expression, "~>", !;

pre_annotation = "!" | "?" | "??";
post_annotation = "?";

annotated_type_expression = 
    [pre_annotation], inner_annotated_type_expression, [post_annotation];

inner_annotated_type_expression =
   basic_inner_annotated_type_expression |
   function_type_expression |
   relation_type_expression |
   action_type_expression |
   tr_type_expression;

basic_inner_annotated_type_expression =
    basic_annotated_type_expression |
    annotated_compound_type_expression |
    annotated_list_type_expression |
    "{", type_expression, "}";

basic_annotated_type_expression = 
     atom | var | annotated_tuple_type_expression | ("(", ")");

annotated_tuple_type_expression =
    "(", annotated_type_expression, {",", annotated_type_expression}, ")";

annotated_compound_type_expression =
    ( atom, "(", annotated_type_expression, 
    	  {",", annotated_type_expression}, ")" ) |
    ( atom, annotated_type_expression );

    
annotated_list_type_expression =
    "[", annotated_type_expression, "]";
    
(* ------ declarations ------ *)

declaration =
    rule_declaration |       
    global_declaration |
    percept_declaration |
    belief_declaration |
    durative_declaration |
    discrete_declaration |
    task_start_declaration |
    task_atomic_declaration |
    resources_declaration;

rule_declaration = 
    name_seq, ":", 
    (
        fun_rel_act_tr_type_expression_seq |
        function_type_expression_seq |
        relation_type_expression_seq |
        action_type_expression_seq |
        tr_type_expression 
     );

name_seq = atom, {",", atom};

global_declaration = ("int" | "num" ), atom, ":=",  arith_term;

percept_declaration =
    "percept", tr_decl_element, {",", tr_decl_element};

belief_declaration =
    "belief", tr_decl_element, {",", tr_decl_element};

durative_declaration =
    "durative", tr_decl_element, {",", tr_decl_element};

discrete_declaration =
    "discrete", tr_decl_element, {",", tr_decl_element};

tr_decl_element =
    atom, ":", "(", [type_expression_seq], ")";

task_start_declaration =
    "task_start", atom, ":", type_expression_seq;

task_atomic_declaration =
    "task_atomic", atom, ":", type_expression_seq;

resources_declaration =
    "resources", type_expression_seq;

(* ------ function definitions ------ *)
function_rule_definition = 
    ( atom_or_compound,"->", term ) |
    ( atom_or_compound, "::", simple_condition_seq, "->", term );  

(* ------ relation definitions ------ *)
relation_rule_definition = 
    atom_or_compound |
    ( atom_or_compound, "<=", condition_seq ) |
    ( atom_or_compound, "::", simple_condition_seq, "<=", condition_seq ) |
    ( atom_or_compound, "::", simple_condition_seq );  

(* ------ action definitions ------ *)
action_rule_definition = 
    atom_or_compound |
    ( atom_or_compound, "~>>", action_seq ) |
    ( atom_or_compound, "::", simple_condition_seq, "~>>", action_seq );

(* ------ TR program definitions ------ *)
tr_program_definition =
    atom_or_simple_compound, "{", tr_rules, "}";

tr_rules =  tr_rule, [tr_rules];

tr_rule  = tr_rule_LHS, "~>", tr_rule_RHS;

tr_rule_LHS =
    simple_condition_seq, [tr_rule_while_until];

tr_rule_while_until =
    ( "min", arith_term ) |
    ( "while_until", simple_condition_seq ) |
    ( "while", while_until_part, "until", while_until_part ) |
    ( "while", while_until_part ) |
    ( "until", while_until_part );

while_until_part =
    simple_condition_seq | 
    ( simple_condition_seq, "min", arith_term ) |
    ( "min", arith_term );

tr_rule_RHS =
    ( tr_action, [wait_repeat], ["++", call_term] );

tr_action =
    ( "(", ")" ) | tr_action_seq | tr_timed_seq;

tr_action_seq = ( ( "(", ")" ) | call_term ), [",", tr_action_seq];
tr_timed_seq = 
    ( tr_timed_for, ";", call_term ) |
    ( tr_timed_for , ";",  tr_timed_for, 
      		   { ";",  tr_timed_for}, [";", call_term]);

tr_timed_for = tr_timed_seq_action, "for", arith_term;

tr_timed_seq_action = ( "(", ")" ) | call_term | ( "(", tr_action_seq, ")" );

tr_action_seq = call_term, [",",  tr_action_seq];

wait_repeat = "wait", arith_term, ["^", arith_term];

(* ------ terms ------ *)

term = 
     ( predication | simple_action |
     arith_term | append_term | concat_term |
     set_term | apply_term | global_val | pedro_addr | compound | basic_term);

basic_term = 
      (
	   ("(", term, ")") |
	   list_comprehension |
	   set_comprehension |
	   tuple_constructor |
	   list_constructor |
	   set_constructor |
	   size_term |
	   atom | string | var | int | num
    ), !;

arith_term = 
    mult_div_term,
    [
	("+", arith_term ) |
	( "-", arith_term ) |	   
	( "\\/", arith_term ) |	   
	(  "/\\", arith_term )
    ];

mult_div_term =
   (
       exp_term,
       [
	  ( "*", mult_div_term ) |
	  ( "/", mult_div_term ) |
	  ( "//", mult_div_term ) |
	  ( "rem", mult_div_term ) |
	  ( "div", mult_div_term ) |
	  ( "<<", mult_div_term ) |
	  ( ">>", mult_div_term ) 
       ]
   ) |
   ( "(", arith_term, ")" );

exp_term =
    basic_arith_term, [ ( "**", exp_term ) ];


basic_arith_term =
	int | num | var | compound | size_term | ("$", atom) |
        ( "(", arith_term, ")" ) |
        ( "+", basic_arith_term ) |
        ( "-", basic_arith_term );

size_term = "#", size_term_body;

size_term_body = (var | compound | list_constructor | string | set_constructor |
	    	      list_comprehension | set_comprehension ) |
		 ("(", append_term, ")") |
		 ("(", concat_term, ")") |
		 ("(", size_term_body, ")");

append_term = list_term, "<>", ( list_term | append_term );
concat_term = string_term, "++", ( string_term | concat_term ); 

list_term = var | compound | list_constructor | list_comprehension  |
	      ("(", list_term, ")") |
              ("(", append_term, ")");

string_term = (var | compound | string ) |
	      ("(", string_term, ")") |
              ("(", concat_term, ")");         

list_comprehension = 
    "[", (var | ("(", var_list, ")")), "::", 
                simple_exists_condition, "]";
set_comprehension = 
    "{", (var | ("(", var_list, ")")), "::", 
                simple_exists_condition, "}";

var_list = var, {",", var};

tuple_constructor = "(", term, ",", term, {",", term}, ")";

%compound = basic_compound, { term | ("(", ")") };
%basic_compound = (atom | var), (term | ("(", ")"));

compound = (atom | var), compound_args;
compound_args = (basic_term | ("(", ")")), [compound_args].

simple_compound = atom, term;

arg_list = term, {",", term};
braketed_arg_list  = ("(", ")") | ("(", arg_list, ")");

list_constructor = "[", list_constructor_args,
		   	("]" | ("|", list_term, "]") | 
			(",", "..", "]") | (",", "..", list_term, "]")), !;

list_constructor_args = term, [",", list_constructor_args].

set_constructor = "{", arg_list, "}";

basic_set_term = var | compound | set_comprehension | set_constructor;

set_term = set_inter_expr | 
           (set_inter_expr, "union", set_term) |
           (set_inter_expr, "diff", set_term);

set_inter_expr = basic_set_term |
               (basic_set_term, "inter", set_inter_expr) |
               ("(", set_term, ")");

apply_term = basic_term, "@..", (list_term);

global_val = "$", atom;

pedro_addr = (atom | var), [":", (atom | var)], ["@", (atom | var)];
agent_handle = (atom | var), ["@", (atom | var)];


(* ------ conditions ------ *)

condition_seq = condition, {"&", condition};

simple_condition_seq = 
    simple_condition, ["&", simple_condition_seq];

simple_condition =
     predication |
     ( "not", predication ) |
     ( "not", "(", predication, ")" ) |
     ( "once", predication ) |
     ( "once", "(", predication, ")" );

forall_condition =
    "forall", var_list, "(", simple_condition_seq, "=>", 
            simple_exists_condition, ")";

simple_exists_condition = 
     simple_condition_seq |
    "exists", var_list, simple_condition_seq |
    "exists", var_list, "(", simple_condition_seq, ")";

exists_condition = 
    condition_seq |
    "exists", var_list, condition_seq ;


condition = 
    forall_condition | 
    simple_condition;

predication = 
     compound | atom |
     type_test |
     ( "mode_correct", brac_call_term ) |
     ( "call", brac_call_term ) |
     ( arith_term, ">", arith_term ) |
     ( arith_term, ">=", arith_term ) |
     ( arith_term, "<", arith_term ) |
     ( arith_term, "=<", arith_term ) |
     ( term,  "=", term ) |
     ( term,  "\=",  term ) |
     ( term,  "@>", term ) |
     ( term,  "@>=", term ) |
     ( term,  "@<", term ) |
     ( term,  "@=<", term ) |
     ( term,  "@=", term ) |
     ( term, "in", (list_term | string_term | set_term) ) |
     ( compound, "=?", simple_term, "@..", list_term ) |
     ( ( list_term | append_term ), "=?", append_term ) |
     ( ( string_term | concat_term ), "=?", eq_string_term );

type_test = "type", "(", term, ",", annotated_type_expression, ")";

call_term = var | atom | compound;
brac_call_term = ("(", call_term, ")") | call_term;

simple_call_term = var | atom | simple_compound;
brac_simple_call_term = ("(", simple_call_term, ")") | simple_call_term;

eq_string_term = string_q, "++", string_q, {"++", string_q};
string_q = string_term | (string_term, "?", condition );            


(* ------ actions ------ *)

action_seq = action, {";", action};

action = simple_action | forall_action;

simple_action_seq = 
    simple_action, {";", simple_action};

forall_action =
     "forall", var_list, "(", simple_condition_seq, "~>>", 
          simple_action_seq, ")";

simple_action = 
     compound | atom |
     ( "do", brac_call_term ) |
     ( atom, ":=", arith_term ) |
     ( atom, "+:=", arith_term ) |
     ( atom, "-:=", arith_term ) |
     ( "remember", brac_simple_call_term, ["for", arith_term] ) |
     ( "rememberA", brac_simple_call_term, ["for", arith_term] ) |
     ( "forget", brac_simple_call_term, ["after", arith_term] ) |
     ( "replace", brac_simple_call_term, "by", simple_call_term ) |
     ( "replaceA", brac_simple_call_term, "by", simple_call_term ) |
     ( "start_task", (atom | var), call_term ) |
     ( "kill_task", (atom | var) ) |
     ( "start_agent", (atom | var), agent_handle, 
                             ("all" | "updates" | "user") ) |
     ( "log", agent_handle ) |
     ( term, "to", pedro_addr ) |
     ( term, "from", pedro_addr ) |
     ( "fork", brac_call_term, "as", (atom | var) );
           
            
(* ------ interpreter entry ------ *)

interpreter_entry = 
    exists_condition |  
    action_seq |
    ( "watch", atom ) |
    ( "watchC", atom ) |
    ( "unwatch", atom ) |
    ( "set_num_answers", int ) |
    ( int, var_list, "?", condition_seq ) |
    ( var_list, "?", condition_seq ) |
    ( int, "?", condition_seq ) |
    ( "prolog", prolog_calls ) |
    "prolog"  |
    "types" |
    ( "types", atom ) |
    "stypes" |
    ( "stypes", atom ) |
    "show" |
    ( "show", atom ) |
    ( "consult", atom ) |
    ( "[", atom, {",", atom}, "]" ) |
    ( "pconsult", atom ) |
    ( "!", term );

(* can use "&", and "," in prolog calls *)
prolog_calls =  
    ( action | condition ),  [("&" | ","), prolog_calls]; 
